Index: ncurses-6.0+20161126/ncurses/tinfo/alloc_entry.c
===================================================================
--- ncurses-6.0+20161126.orig/ncurses/tinfo/alloc_entry.c	2022-05-30 12:58:21.000000000 +0200
+++ ncurses-6.0+20161126/ncurses/tinfo/alloc_entry.c	2022-06-29 15:38:53.794639205 +0200
@@ -52,8 +52,6 @@
 #define ABSENT_OFFSET    -1
 #define CANCELLED_OFFSET -2
 
-#define MAX_STRTAB	4096	/* documented maximum entry size */
-
 static char *stringbuf;		/* buffer for string capabilities */
 static size_t next_free;	/* next free character in stringbuf */
 
@@ -71,7 +69,7 @@
 #endif
 
     if (stringbuf == 0)
-	TYPE_MALLOC(char, (size_t) MAX_STRTAB, stringbuf);
+ 	TYPE_MALLOC(char, (size_t) MAX_ENTRY_SIZE, stringbuf);
 
     next_free = 0;
 
@@ -107,11 +105,11 @@
 	 * Cheat a little by making an empty string point to the end of the
 	 * previous string.
 	 */
-	if (next_free < MAX_STRTAB) {
+	if (next_free < MAX_ENTRY_SIZE) {
 	    result = (stringbuf + next_free - 1);
 	}
-    } else if (next_free + len < MAX_STRTAB) {
-	_nc_STRCPY(&stringbuf[next_free], string, MAX_STRTAB);
+    } else if (next_free + len < MAX_ENTRY_SIZE) {
+	_nc_STRCPY(&stringbuf[next_free], string, MAX_ENTRY_SIZE);
 	DEBUG(7, ("Saved string %s", _nc_visbuf(string)));
 	DEBUG(7, ("at location %d", (int) next_free));
 	next_free += len;
Index: ncurses-6.0+20161126/ncurses/tinfo/read_entry.c
===================================================================
--- ncurses-6.0+20161126.orig/ncurses/tinfo/read_entry.c	2016-05-29 01:22:52.000000000 +0200
+++ ncurses-6.0+20161126/ncurses/tinfo/read_entry.c	2022-06-29 15:36:11.126540573 +0200
@@ -68,6 +68,7 @@
 {
     int i;
     char *p;
+    bool corrupt = FALSE;
 
     for (i = 0; i < count; i++) {
 	if (IS_NEG1(buf + 2 * i)) {
@@ -77,8 +78,20 @@
 	} else if (MyNumber(buf + 2 * i) > size) {
 	    Strings[i] = ABSENT_STRING;
 	} else {
-	    Strings[i] = (MyNumber(buf + 2 * i) + table);
-	    TR(TRACE_DATABASE, ("Strings[%d] = %s", i, _nc_visbuf(Strings[i])));
+ 	    int nn = MyNumber(buf + 2 * i);
+ 	    if (nn >= 0 && nn < size) {
+ 		Strings[i] = (nn + table);
+ 		TR(TRACE_DATABASE, ("Strings[%d] = %s", i,
+ 				    _nc_visbuf(Strings[i])));
+ 	    } else {
+ 		if (!corrupt) {
+ 		    corrupt = TRUE;
+ 		    TR(TRACE_DATABASE,
+ 		       ("ignore out-of-range index %d to Strings[]", nn));
+ 		    _nc_warning("corrupt data found in convert_strings");
+ 		}
+ 		Strings[i] = ABSENT_STRING;
+ 	    }
 	}
 
 	/* make sure all strings are NUL terminated */
